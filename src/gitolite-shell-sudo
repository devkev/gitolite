#!/bin/bash

# Add something like this to your sudoers:
#
# # This must come after the above SYSADMINS entry, otherwise users
# # in the SYSADMINS alias won't be able to use gitolite properly.
# Cmnd_Alias GITOLITE = /home/git/gitolite/src/gitolite-shell-sudo
# Defaults!GITOLITE    env_keep += "SSH_CONNECTION SSH_ORIGINAL_COMMAND"
# ALL     ALL = (git)  NOPASSWD: GITOLITE

function is_admin {
	case "$1" in
		# FIXME: sucks to be hardcoding this in here like this.  Sorry.
		*900|root)
			return 0
			;;
	esac
	return 1
}

if [ "${SUDO_USER+set}" != "set" ]; then    
	[ "${1+set}" != "set" ] && exit 1
	args=""
	if [ "${SSH_CONNECTION+set}" = set ]; then
		if [ "${SSH_ORIGINAL_COMMAND+set}" = set ]; then
			# check the original command for key self-service commands
			# *carefully* - remembering that the original command is
			# untrusted user input.
			case "$SSH_ORIGINAL_COMMAND" in
				"authkeys add "*)
					untrusted_key_material="${SSH_ORIGINAL_COMMAND#authkeys add }"

					ro=
					case "$untrusted_key_material" in
						"-r "*|"-ro "*|"--ro "*|"--readonly "*|"--read-only "*)
							ro=y
							untrusted_key_material="${untrusted_key_material#* }"
							case "$untrusted_key_material" in
								"-p "*|"-project "*|"--project "*|"-g "*|"--group "*)
								untrusted_key_material="${untrusted_key_material#* }"
								untrusted_project="${untrusted_key_material%% *}"
								untrusted_key_material="${untrusted_key_material#* }"
							esac
							;;
					esac

					# Check it's kosher.
					trusted_key_material="$(sed -ne '1 s,^\(ssh-[a-zA-Z0-9]\+\s\+[a-zA-Z0-9+/]\+=\?=\?\)\s.*$,\1,p' <<< "$untrusted_key_material")"
					if [ ! "$trusted_key_material" ]; then
						echo "Error: Invalid key format"
						exit 1
					fi

					suffix=""
					suffix_other="_ro"
					if [ "$ro" ]; then
						suffix="_ro"
						suffix_other=""

						trusted_project="$(sed -ne '1 s,^\([a-zA-Z0-9._-]\+\).*$,\1,p' <<< "$untrusted_project")"

						# Check that the user is actually in this group, otherwise they are trying to snoop.
						groups=($("${0%/*}"/unix-groups "$USER"))
						case "${groups[*]}" in
							*" $trusted_project "*|*" $trusted_project"|"$trusted_project "*|"$trusted_project")
								# Fine.
								;;
							*)
								# Not fine.
								echo "Error: you are not a member of $trusted_project"
								exit 1
								;;
						esac

					fi

					# Check it doesn't already exist.
					if grep -sq ^"$trusted_key_material" ~/.ssh/authorized_keys$suffix; then
						# Already there
						if [ "$trusted_project" ]; then
							# Are we trying to convert/change the project of a r/o key?
							if grep -sq ^"$trusted_key_material $trusted_project"$ ~/.ssh/authorized_keys$suffix; then
								# Key is already there with this project.
								echo "Key already exists."
								exit 0
							else
								echo "Converting read-only key's previous project to be $trusted_project"
								# Here, just remove it, and it will be added below.
								sed -i -e '\,^'"$trusted_key_material"',d' ~/.ssh/authorized_keys$suffix
							fi
						else
							echo "Key already exists."
							exit 0
						fi
					fi

					if grep -sq ^"$trusted_key_material" ~/.ssh/authorized_keys$suffix_other; then
						# It's already there, but in the OTHER file.  ie. user (apparently) wants
						# to convert a r/o key to r/w (unsafe, not allowed, delete first then re-add),
						# or convert a r/w key to r/o (fine, though emit warning).
						if [ "$suffix" = _ro ]; then
							echo "Converting previously read-write key to be read-only..."
							# Here, just remove it from ~/.ssh/authorized_keys$suffix_other,
							# it will be added to ~/.ssh/authorized_keys$suffix below.
							sed -i -e '\,^'"$trusted_key_material"',d' ~/.ssh/authorized_keys$suffix_other
						else
							echo "Converting a read-only key to be read-write is dangerous."
							echo "Is this really what you intended?"
							echo "If so, you must first delete the read-only key, and then"
							echo "separately add it again as read-write."
							exit 1
						fi
					fi

					if [ "$trusted_project" ]; then
						trusted_key_material="$trusted_key_material $trusted_project"
					fi

					# Key is nowhere to be seen (or was read-write, but has been dealt with above).
					mkdir -p ~/.ssh
					echo "$trusted_key_material" >> ~/.ssh/authorized_keys$suffix

					# tell gitolite to update its copy of the keys.
					args="-u"
					# and make sure that the gitolite hosting user can see
					# our authorised keys file.
					chmod o+x ~ ~/.ssh
					chmod o+r ~/.ssh/authorized_keys ~/.ssh/authorized_keys_ro
					;;
				"authkeys del "*)
					echo "Key deletion not yet implemented."
					# FIXME: remember to do ro keys
					exit $?   # this will need to go away when del is implemented
					;;
				"authkeys update")
					# tell gitolite to update its copy of the keys.
					args="-u"
					# and make sure that the gitolite hosting user can see
					# our authorised keys file.
					chmod o+x ~ ~/.ssh
					chmod o+r ~/.ssh/authorized_keys ~/.ssh/authorized_keys_ro
					;;
				"authkeys list"|"authkeys list "*)
					if [ -s ~/.ssh/authorized_keys ]; then
						echo "Authorised public keys for $USER:"
						cat ~/.ssh/authorized_keys
					else
						echo "No authorised public keys for $USER."
					fi
					echo ""
					if [ -s ~/.ssh/authorized_keys_ro ]; then
						echo "Authorised READ-ONLY public keys for $USER:"
						cat ~/.ssh/authorized_keys_ro
					else
						echo "No authorised read-only public keys for $USER."
					fi
					exit $?
					;;
				"rsync"|"rsync "*)
					# Special case for admins...
					if is_admin "$USER"; then
						eval exec $SSH_ORIGINAL_COMMAND
					fi
					;;
			esac
			
		else
			# If we get this far, but $SSH_ORIGINAL_COMMAND isn't set,
			# then it's because the user has just done a plain "ssh host".
			# If the user is permitted, this will get them a normal login
			# shell.  Otherwise they get passed through to gitolite as per
			# normal.  This allows admins of the server to get on as their
			# normal user (from which they can sudo to root or the gitolite
			# hosting user), while still allowing them to use gitolite from
			# their normal user account just like other, non-admin users.
			# It does preclude admins from being able to do things like
			# "ssh -t host sudo service sshd restart", but they can get over
			# that.  Actually the real problem here is that it breaks
			# rsync, which is somewhat more significant.
			# FIXME: Investigate using ssh subsystems as a way around this.
			if is_admin "$USER"; then
				exec $(getent passwd "$USER" | awk -F: '{print $7}') -l
			fi
		fi
	fi
	sudo -u "$1" "$0" $args
else
	if [ "$1" = "-u" ]; then
		# Update the auto-keys for $SUDO_USER
		if [ -e ~/.gitolite/keydir/auto/$SUDO_USER ]; then
			mv ~/.gitolite/keydir/auto/$SUDO_USER{,.old}
		fi
		i=1
		while read line; do
			outfile=~/.gitolite/keydir/auto/$SUDO_USER/$i/${SUDO_USER}.pub
			mkdir -p "${outfile%/*}"
			echo "$line" > "$outfile"
			i=$(($i+1))
		done < $(eval echo ~$SUDO_USER)/.ssh/authorized_keys
		while read type key project; do
			outfile=~/.gitolite/keydir/auto/$SUDO_USER/$i/${SUDO_USER}_ro.pub
			if [ "$project" ]; then
				outfile=~/.gitolite/keydir/auto/$SUDO_USER/$i/$project.pub
			fi
			mkdir -p "${outfile%/*}"
			echo "$type $key $project" > "$outfile"
			i=$(($i+1))
		done < $(eval echo ~$SUDO_USER)/.ssh/authorized_keys_ro
		rm -rf ~/.gitolite/keydir/auto/$SUDO_USER.old
		"${0%-shell-sudo}" trigger SSH_AUTHKEYS
		exit $?
	fi
	exec "${0%-sudo}" "$SUDO_USER"
fi

