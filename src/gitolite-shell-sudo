#!/bin/bash

# Add something like this to your sudoers:
#
# # This must come after the above SYSADMINS entry, otherwise users
# # in the SYSADMINS alias won't be able to use gitolite properly.
# Cmnd_Alias GITOLITE = /home/git/gitolite/src/gitolite-shell-sudo
# Defaults!GITOLITE    env_keep += "SSH_CONNECTION SSH_ORIGINAL_COMMAND"
# ALL     ALL = (git)  NOPASSWD: GITOLITE

if [ "${SUDO_USER+set}" != "set" ]; then    
	[ "${1+set}" != "set" ] && exit 1
	args=""
	if [ "${SSH_CONNECTION+set}" = set ]; then
		if [ "${SSH_ORIGINAL_COMMAND+set}" = set ]; then
			# check the original command for key self-service commands
			# *carefully* - remembering that the original command is
			# untrusted user input.
			case "$SSH_ORIGINAL_COMMAND" in
				"authkeys add "*)
					untrusted_key_material="${SSH_ORIGINAL_COMMAND#authkeys add }"
					# Check it's kosher.
					trusted_key_material="$(sed -ne '1 s,^\(ssh-[a-zA-Z0-9]\+\s\+[a-zA-Z0-9+/]\+=\?=\?\)\s.*$,\1,p' <<< "$untrusted_key_material")"
					if [ ! "$trusted_key_material" ]; then
						echo "Error: Invalid key format"
						exit 1
					fi

					# FIXME: "readonly" keys would be good too, down the track.

					# FIXME: Need to check it doesn't already exist.
					if grep -sq ^"$trusted_key_material" ~/.ssh/authorized_keys; then
						# Already there
						echo "Key already exists."
						exit 0
					else
						mkdir -p ~/.ssh
						echo "$trusted_key_material" >> ~/.ssh/authorized_keys
					fi

					# tell gitolite to update its copy of the keys.
					args="-u"
					# and make sure that the gitolite hosting user can see
					# our authorised keys file.
					chmod o+x ~ ~/.ssh
					chmod o+r ~/.ssh/authorized_keys
					;;
				"authkeys del "*)
					echo "Key deletion not yet implemented."
					exit $?   # this will need to go away when del is implemented
					;;
				"authkeys update")
					# tell gitolite to update its copy of the keys.
					args="-u"
					# and make sure that the gitolite hosting user can see
					# our authorised keys file.
					chmod o+x ~ ~/.ssh
					chmod o+r ~/.ssh/authorized_keys
					;;
				"authkeys list"|"authkeys list "*)
					if [ -s ~/.ssh/authorized_keys ]; then
						cat ~/.ssh/authorized_keys
					else
						echo "No authorised keys for $USER."
					fi
					exit $?
					;;
				"rsync"|"rsync "*)
					# Special case for admins...
					case "$USER" in
						# FIXME: sucks to be hardcoding this in here like this.  Sorry.
						*900|root)
							eval exec $SSH_ORIGINAL_COMMAND
							;;
					esac
					;;
			esac
			
		else
			# If we get this far, but $SSH_ORIGINAL_COMMAND isn't set,
			# then it's because the user has just done a plain "ssh host".
			# If the user is permitted, this will get them a normal login
			# shell.  Otherwise they get passed through to gitolite as per
			# normal.  This allows admins of the server to get on as their
			# normal user (from which they can sudo to root or the gitolite
			# hosting user), while still allowing them to use gitolite from
			# their normal user account just like other, non-admin users.
			# It does preclude admins from being able to do things like
			# "ssh -t host sudo service sshd restart", but they can get over
			# that.  Actually the real problem here is that it breaks
			# rsync, which is somewhat more significant.
			# FIXME: Investigate using ssh subsystems as a way around this.
			case "$USER" in
				# FIXME: sucks to be hardcoding this in here like this.  Sorry.
				*900|root)
					exec $(getent passwd "$USER" | awk -F: '{print $7}') -l
					;;
			esac
		fi
	fi
	sudo -u "$1" "$0" $args
else
	if [ "$1" = "-u" ]; then
		# Update the auto-keys for $SUDO_USER
		if [ -e ~/.gitolite/keydir/auto/$SUDO_USER ]; then
			mv ~/.gitolite/keydir/auto/$SUDO_USER{,.old}
		fi
		i=1
		while read line; do
			mkdir -p ~/.gitolite/keydir/auto/$SUDO_USER/$i
			echo "$line" > ~/.gitolite/keydir/auto/$SUDO_USER/$i/$SUDO_USER.pub
			i=$(($i+1))
		done < $(eval echo ~$SUDO_USER)/.ssh/authorized_keys
		rm -rf ~/.gitolite/keydir/auto/$SUDO_USER.old
		"${0%-shell-sudo}" trigger SSH_AUTHKEYS
		exit $?
	fi
	exec "${0%-sudo}" "$SUDO_USER"
fi

